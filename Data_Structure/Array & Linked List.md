# Array & Linked List
   
## Array
**배열(Array)**   
가장 기본적인 자료구조인 Array는 논리적 저장 순서와 물리적 저장 순서가 일치한다. index로 해당하는 element에 접근할 수 있다.   
그래서 찾고자하는 element의 index값을 알고 잇다면 O(1)의 시간복잡도로 해당 element에 접근할 수 있다.   
   
**다차원 배열**   
다차원 배열은 배열의 배열을 선언하여 중첩하는 것을 의마한다.   
1차원 배열이 논리적으로 line형태 라면 2차원 배열은 face형태이다.   
2차원 배열의 형태의 예를 들자면 위 그림2와 같다.   
그리고 컴퓨터의 메모리는 사진2처럼 입체적인 공간이 아닌 선형 공간이므로 실제로는 그림3과 같이 저장된다.   
   
**배열의 특징**   
같은 타입의 데이터를 나열한 선형 자료구조이다.   
연속된 메모리 공간에 순차적으로 저장   
논리적 저장 순서와 물리적 저장 순서가 일치한다.   
생성할 때 데이터를 저장하는데 필요한 메모리를 한 번에 확보해서 사용한다.   
배열의 크기는 고정. 선언할 때 배열의 크기를 정하고, 변경할 수 없다.   
   
**배열의 element삭제**   
배열의 element를 한 개 삭제할 경우 삭제한 원소보다 큰 인덱스 값을 갖는 element들은 1씩 옮겨줘야하기 때문에 시간 복잡도는 O(n)이다.   
   
**배열의 element삽입**   
배열의 element를 한 개 삽입할 경우 전제 조건은 배열에 빈칸이 있다는 것이다. 빈 칸이 없다면 요소를 삽입할 때 공간이 부족하기 때문에 새로운 배열을 선언하고, 기존 배열의 값을 새로운 배열에 복사한 후 N+1번째 요소를 삽입한다. 이후 기존 배열을 가리키던 변수가 새로운  배열을 가리키도록 한다.   
   
**element 삽입의 부작용**   
새로운 크기의 배열을 선언하는 과정에서 메모리 소모.   
이전 배열에서 새로운 배열로 값을 복사하는 과정에서 시간이 소요.   
기존 배열을 참조하고 있던 다른 변수들의 참조는 변경되지 않기 때문에 여전히 이전 배열을 가리키고 있다.   
   
**Array의 장점**   
인덱스를 통해 모든 데이터에 직접 엑세스하기 때문에 엑세스 속도가 빠르다.   
부가적인 정보가 없어서 기록 밀도가 1이다.   
가장 간단하고 사용하기 쉽다.   
   
**Array의 단점**   
삽입과 삭제가 어렵고 오래걸린다.   
배열의 크기를 바꿀 수 없다.   
연속된 메모리라서 공간 낭비가 발생한다.   
   
## Linked List
Array의 삽입과 삭제에 대한 부작용을 해결하기 위해 나온 자료구조가 Linked List이다.   
각각 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다.   
따라서 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)만에 해결할 수 있다.   
   
**Linked List의 장점**   
자료의 삽입과 삭제가 용이하다.   
리스트 내에서 자료이동이 필요하지 않다.   
사용 후 기억장소의 재사용이 가능하다.   
연속적인 기억 장소의 할당이 필요하지 않다.   
   
**Linked List의 단점**   
포인터의 사용으로 인해 공간의 낭비가 있다.   
알고리즘이 복잡하다.   
특정 자료의 탐색 시간이 많이 소요된다.   
   
## 정리 및 생각
- Array는 index만 알고있다면 특정 자료의 탐색시간이 매우 빠르고 Linked List는 특정 자료를 탐색하려면 첫 번째 index부터 전부 탐색해야한다.
- Array는 element의 삽입과 삭제 과정에서 메모리와 시간소모가 큰 반면,
- Linked List는 삽입과 삭제과정에서 매우 빠르다.
   
**내 생각**   
근데 내가 쓰는 Swift와 Python은 Array의 크기가 가변적이다.   
찾아본 결과, 대부분의 언어는 표준 라이브러리에서 동적배열을 지원하기 때문이라고한다.   
그리고 원리는 내가 선언한 배열의 크기가 4라면 8만큼 메모리 여유공간을 확보하고 여유공간마저 꽉차면 재할당하는 방식이라고한다.
